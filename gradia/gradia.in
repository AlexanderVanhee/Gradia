#!/usr/bin/env python3
# gradia.in
#
# Copyright (C) 2025 Alexander Vanhee
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# SPDX-License-Identifier: GPL-3.0-or-later
import os
import sys
import signal
import locale
import gettext
import logging
from datetime import datetime
import gi
gi.require_version('Xdp', '1.0')
from gi.repository import Xdp, GLib
logging.getLogger("PIL").setLevel(logging.WARNING)
VERSION = '@VERSION@'
pkgdatadir = '@PKGDATA_DIR@'
localedir = '@LOCALE_DIR@'
sys.path.insert(1, pkgdatadir)
signal.signal(signal.SIGINT, signal.SIG_DFL)
locale.bindtextdomain('gradia', localedir)
locale.textdomain('gradia')
gettext.install('gradia', localedir)

from gradia.screenshot_dimension_window import ScreenshotResolutionHandler

class QuickStartScreenshotTaker:
    def __init__(self):
        self.portal = Xdp.Portal()
        self._loop = None
        self._result_path = None

    def take_screenshot(self, flags=Xdp.ScreenshotFlags.INTERACTIVE, delay_ms=0) -> str | None:
        def on_finish(portal, result, user_data):
            from gi.repository import Gio
            try:
                uri = portal.take_screenshot_finish(result)
                file = Gio.File.new_for_uri(uri)
                path = file.get_path()
                if not path:
                    raise Exception("Failed to get local file path from URI")
                self._result_path = path
            except Exception as e:
                print("Screenshot failed:", e)
                self._result_path = None
            finally:
                if self._loop:
                    self._loop.quit()

        def start_screenshot():
            self.portal.take_screenshot(None, flags, None, on_finish, None)
            return False

        self._loop = GLib.MainLoop()
        if delay_ms > 0:
            GLib.timeout_add(delay_ms, start_screenshot)
        else:
            start_screenshot()
        self._loop.run()
        return self._result_path

if __name__ == '__main__':
    mode = None
    delay = 0
    screenshot_only = False

    for arg in sys.argv[1:]:
        if arg.startswith('--screenshot'):
            parts = arg.split('=', 1)
            if len(parts) == 1 or parts[1].strip().upper() == 'DIMENSION':
                screenshot_only = True
                mode = 'INTERACTIVE'
            else:
                mode = parts[1].strip().upper()
        elif arg.startswith('--delay'):
            parts = arg.split('=', 1)
            if len(parts) == 2:
                try:
                    delay = int(parts[1])
                except ValueError:
                    print("Invalid delay value. Using default of 0.")
                    delay = 0

    if mode in ('INTERACTIVE', 'FULL'):
        flags = Xdp.ScreenshotFlags.INTERACTIVE if mode == 'INTERACTIVE' else Xdp.ScreenshotFlags.NONE
        screenshotter = QuickStartScreenshotTaker()
        screenshot_path = screenshotter.take_screenshot(flags=flags, delay_ms=delay)

        if screenshot_path is None:
            print("Screenshot was cancelled or failed. Exiting.")
            sys.exit(1)

        if screenshot_only:
            handler = ScreenshotResolutionHandler()
            success = handler.handle_screenshot_resolution(screenshot_path)
            sys.exit(0 if success else 1)
        else:
            sys.argv.append(f"--screenshot-file={screenshot_path}")

    gi.require_version('Gtk', '4.0')
    gi.require_version('Adw', '1')
    from gi.repository import Gio
    resource = Gio.Resource.load(
        os.path.join(pkgdatadir, 'gradia.gresource'))
    resource._register()
    from gradia import main
    sys.exit(main.main(VERSION))
